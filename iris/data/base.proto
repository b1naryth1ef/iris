
enum PacketType {
  Invalid = 0;
  BeginHandshake = 1;
  DenyHandshake = 2;
  AcceptHandshake = 3;
  CompleteHandshake = 4;
  Ping = 5;
  Pong = 6;
  Close = 7;
  RequestPeers = 8;
  ListPeers = 9;
  RequestShards = 10;
  ListShards = 11;
  SubscribeShard = 12;
  SearchEntries = 13;
  EntriesSearchResult = 14;
  RequestEntries = 15;
  ListEntries = 16;
}

message IStamp {
  required string entry = 1;
  required string notary = 2;
  required string parent = 3;
  required bytes signature = 4;
}

message IEntry {
  required string id = 1;
  required string shard = 2;
  required string author = 3;
  required bytes payload = 4;
  required bytes signature = 5;
  required string created = 6;
  required uint64 proof = 7;

  // Only set if we get the full entry
  repeated IStamp stamps = 8;
  optional IUser author_obj = 9;
}

message IUser {
  required string id = 1;
  required string pubkey = 2;
  required string signkey = 3;
  required string nickname = 4;
  required string signature = 5;
  optional string first_authed = 6;
  optional string last_authed = 7;
}

message IPeer {
  required string ip = 1;
  required uint32 port = 2;
  required IUser user = 3;
}

message IShard {
  required string id = 1;
  required string uid = 2;
  required string name = 3;
  required string desc = 4;
  required uint32 pow_load = 5;
  required string pow_char = 6;
  required bool public = 7;
  required bytes meta = 8;
  repeated IPeer peers = 9;
}

message Packet {
  required PacketType type = 1;
  required bytes data = 2;
  optional string ticket = 3;
}

message PacketBeginHandshake {
  required IPeer peer = 1;
  required uint32 timestamp = 2;
  required uint32 challenge = 3;

  // List of shards we are "subscribed" too
  repeated string shards = 4;
}

message PacketDenyHandshake {
  required string reason = 1;
  required uint32 backoff = 2;
}

message PacketAcceptHandshake {
  required IPeer peer = 1;
  required bytes response = 2;
  required uint32 challenge = 3;
  repeated string shards = 4;
}

message PacketCompleteHandshake {
  required bytes response = 1;
}

message PacketPing {
  required uint32 timestamp = 1;
  required uint32 challenge = 2;
}

message PacketPong {
  required uint32 timestamp = 1;
  required bytes response = 2;
}

message PacketClose {
  optional string reason = 1;
}

message PacketRequestPeers {
  required uint32 maxsize = 1;
  repeated string shards = 2;
}

message PacketListPeers {
  repeated IPeer peers = 1;
}

message PacketSubscribeShard {
  required string shard = 1;
  required bool state = 2;
}

message PacketRequestShards {
  required uint32 limit = 1;
  repeated string shards = 2;
  optional bool peers = 3;
}

message PacketListShards {
  repeated IShard shards = 1;
  repeated IShard peers = 2;
}

message PacketSearchEntries {
  required string shard = 1;
  required uint32 limit = 2;
  optional string query = 3;
}

message PacketEntriesSearchResult {
  repeated string entries = 1;
}

message PacketRequestEntries {
  required string shard = 1;
  repeated string entries = 2;
  required uint32 limit = 3;

  optional bool with_authors = 4;
  optional bool with_stamps = 5;
}

message PacketListEntries {
  repeated IEntry entries = 1;
}


